# Deep Dive: Token Repository Code Explanation

This document provides a comprehensive, line-by-line explanation of the Token Repository implementation for Refresh Token Rotation.

---

## 1. HashToken Function - The Security Guard

```go
func HashToken(token string) string {
    hash := sha256.Sum256([]byte(token))
    return hex.EncodeToString(hash[:])
}
```

### Why do we take a JWT token as input?

When a user logs in, we generate a JWT like this:
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiIxMjM0NSIsImV4cCI6MTczMjM2MjAwMH0.signature
```

This is a **long string** (100-200 characters). We need to store it in the database to track "which tokens are valid."

**But there's a problem:** If we store the **raw JWT string** in the database, and a hacker steals your database backup, they can use those tokens to impersonate users.

**The Solution: Hash it.**

---

### What is `[]byte(token)`?

**The Problem:** The `sha256.Sum256()` function doesn't accept strings. It only works with **bytes** (raw binary data).

**What are bytes?** Everything in a computer is stored as numbers (0-255). A string like `"hello"` is actually stored as:
```
[104, 101, 108, 108, 111]
```
These numbers are called **bytes**.

**What does `[]byte(token)` do?** It converts the string into a **slice of bytes** (a dynamic array of numbers).

Example:
```go
token := "abc"
bytes := []byte(token)
// bytes = [97, 98, 99]
```

**Why does SHA256 need bytes?** Because hashing algorithms work on raw binary data, not human-readable text.

---

### What is `sha256.Sum256(...)`?

**SHA256** is a **Cryptographic Hash Function**.

**What does it do?** It takes any input (like a JWT string) and produces a **fixed-size output** (32 bytes / 256 bits).

**Key Properties:**
1. **One-Way**: You can't reverse it. If you have the hash, you can't get the original token back.
2. **Deterministic**: The same input always produces the same hash.
3. **Unique**: Even a tiny change in input produces a completely different hash.

Example:
```go
Input:  "eyJhbGci..."
Output: a3f5b2c8d1e4f6a7b9c0d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3
```

**Why use SHA256 instead of storing the raw token?**

**Scenario: Database Leak**
- **Without Hashing**: Hacker steals DB → Gets raw JWTs → Logs in as any user.
- **With Hashing**: Hacker steals DB → Gets hashes → **Can't use them** (hashes are useless without the original token).

**How does verification work then?** When a user sends a token:
1. We hash the incoming token.
2. We compare the hash to the stored hash.
3. If they match, the token is valid.

---

### What is `hash[:]`?

**The Problem:** `sha256.Sum256()` returns a **fixed-size array**: `[32]byte`.

But `hex.EncodeToString()` expects a **slice**: `[]byte`.

**What's the difference?**
- **Array** `[32]byte`: Fixed size, can't grow or shrink.
- **Slice** `[]byte`: Dynamic size, can be passed around easily.

**What does `hash[:]` do?** It converts the array to a slice.

```go
hash := [32]byte{1, 2, 3, ...}  // Array
slice := hash[:]                 // Slice (same data, different type)
```

---

### What is `hex.EncodeToString(...)`?

**The Problem:** The hash is raw bytes (numbers 0-255). If we store it directly in the database as bytes, it looks like garbage:
```
[163, 245, 178, 200, ...]
```

**The Solution: Hexadecimal Encoding** - Convert bytes to a human-readable string using **hexadecimal** (base-16).

Example:
```go
Bytes: [163, 245, 178]
Hex:   "a3f5b2"
```

Each byte (0-255) becomes two hex characters (00-FF).

**Why hex?**
- It's compact (2 characters per byte).
- It's safe to store in text databases (no special characters).
- It's reversible (we can convert back to bytes if needed, though we never need to for hashes).

---

## 2. StoreRefreshToken Function - The Vault

```go
func StoreRefreshToken(userID uuid.UUID, token string, expiresAt time.Time) error {
    refreshToken := models.RefreshToken{
        UserID:    userID,
        TokenHash: HashToken(token),
        ExpiresAt: expiresAt,
    }
    return helpers.DB().Create(&refreshToken).Error
}
```

### Why do we take `userID uuid.UUID`?

We need to know **who owns this token**.

**Why UUID instead of int?**
- UUIDs are globally unique (no collisions even across databases).
- They're harder to guess (security).
- They're the standard in your app (consistency).

---

### Why do we take `token string`?

This is the **raw JWT string** generated by `helpers.GenerateToken()`.

**Why not just pass the hash?** Because the hash is created **inside** this function. The caller (Login function) only has the raw token.

---

### Why do we take `expiresAt time.Time`?

We need to store when this token should die.

**Why not calculate it inside this function?** Because the **Login function** already calculated it (7 days from now). We're just storing what we're told.

**Why `time.Time` instead of a string?**
- Databases understand `time.Time` natively.
- We can do date math (e.g., "find expired tokens").

---

### Why `TokenHash: HashToken(token)`?

We **never** store the raw token. We always hash it first for security.

---

### Why `return helpers.DB().Create(&refreshToken).Error`?

**What is `helpers.DB()`?** It returns the database connection (GORM instance).

**What is `.Create(&refreshToken)`?** It inserts the struct into the `refresh_tokens` table.

**Why `&refreshToken` (pointer)?** GORM needs to **modify** the struct (fill in `ID` and `CreatedAt` after insertion). Pointers allow modification.

**What is `.Error`?** GORM returns a result object. `.Error` extracts the error (if any).

**Why return the error?** So the caller (Login function) knows if the save failed.

---

## 3. RotateRefreshToken - The Security Dance

```go
func RotateRefreshToken(oldTokenString string) (string, error) {
    tx := helpers.DB().Begin()
```

### Why do we take `oldTokenString string`?

This is the JWT the user sent in their cookie. We need to:
1. Verify it exists in the database.
2. Revoke it.
3. Issue a new one.

---

### Why `(string, error)` return types?

**First return (`string`)**: The new JWT token (to send back to the user).

**Second return (`error`)**: If something goes wrong (token not found, reuse detected, DB error).

**Why two returns?** Go doesn't have exceptions. Functions return errors explicitly.

---

### Why `tx := helpers.DB().Begin()`?

**What is a Transaction?** A transaction is a **group of database operations** that must **all succeed or all fail together**.

**Real-World Analogy:** Imagine transferring money:
1. Deduct $100 from Account A.
2. Add $100 to Account B.

If Step 2 fails, you **must undo Step 1**. Otherwise, money disappears!

**In our case:**
1. Revoke old token.
2. Create new token.

If Step 2 fails, we **must undo Step 1**. Otherwise, the user has no valid token!

**What does `.Begin()` do?** It starts a transaction. All operations after this use `tx` instead of `helpers.DB()`.

---

### Why `var dbToken models.RefreshToken`?

We need a variable to hold the token we find in the database.

**Why declare it empty?** GORM will fill it with data from the database.

---

### Why `hash := HashToken(oldTokenString)`?

The database stores **hashes**, not raw tokens.

To find the token, we must:
1. Hash the incoming token.
2. Search for that hash in the database.

---

### Why `tx.Where("token_hash = ?", hash).First(&dbToken)`?

**What is `.Where(...)`?** It builds a SQL query: `SELECT * FROM refresh_tokens WHERE token_hash = ?`

**What is the `?`?** A **placeholder** for the `hash` value. GORM safely inserts it (prevents SQL injection).

**What is `.First(&dbToken)`?**
- Executes the query.
- Takes the **first** matching row.
- Fills `dbToken` with the data.

**Why `&dbToken` (pointer)?** GORM needs to modify the variable.

---

### Why `if err != nil { tx.Rollback(); return "", err }`?

**What is `.Error`?** If the token isn't found, GORM returns an error.

**What is `tx.Rollback()`?** It **undoes** all changes made in this transaction (like pressing Ctrl+Z).

**Why rollback?** If the token doesn't exist, we can't proceed. We abort the transaction.

**Why `return "", err`?**
- First return (`""`): No new token (operation failed).
- Second return (`err`): The error message (e.g., "record not found").

---

### Why check `if dbToken.IsRevoked`?

**The Security Scenario:**
1. User logs in → Gets Token A.
2. Hacker steals Token A.
3. Hacker uses Token A → Gets Token B (Token A is revoked).
4. Real user tries to use Token A → **ALARM!**

If `IsRevoked` is true, it means someone already used this token. This is **theft detection**.

---

### Why `tx.Model(&models.RefreshToken{}).Where("user_id=?", dbToken.UserID).Update("is_revoked", true)`?

**Panic Mode**: Revoke **ALL** tokens for this user.

**Why?** We don't know if the hacker or the real user used the token first. To be safe, we lock out **both** and force a fresh login.

**What does this do?** SQL: `UPDATE refresh_tokens SET is_revoked = true WHERE user_id = '...'`

**Important Note:** Even though `dbToken.IsRevoked` is already `true`, this line revokes **all other tokens** for this user (they might have multiple devices logged in).

---

### Why `tx.Commit()` after revoking all tokens?

We want to **save** the security action immediately (revoke all tokens) even though we're returning an error.

---

### Why `dbToken.IsRevoked = true; tx.Save(&dbToken)`?

We mark the old token as "used" so it can't be used again. This is the **normal flow** (no theft detected).

---

### Why generate a new token with 7 days expiration?

This "resets the clock." The user gets another 7 days of inactivity before forced logout.

---

### Why `tx.Rollback()` if token generation fails?

If we can't create a new token, we **undo** the revocation of the old token. This way, the user can try again with their old token.

---

### Why `tx.Commit()` at the end?

This **saves all changes** (revoke old, insert new) as one atomic operation.

If we didn't use a transaction, and the new token creation failed, the old token would be revoked but no new token exists → user locked out!

---

## Multi-Device Scenarios

### Different Tokens Per Device

Every time a user logs in (on any device), they get a **unique Refresh Token**.

**Example:**
- User logs in on **Phone** → Gets Refresh Token A.
- User logs in on **Laptop** → Gets Refresh Token B.
- User logs in on **Tablet** → Gets Refresh Token C.

All three tokens are stored in the database:

| ID | UserID  | TokenHash | IsRevoked |
|----|---------|-----------|-----------|
| 1  | user123 | hash_A    | false     |
| 2  | user123 | hash_B    | false     |
| 3  | user123 | hash_C    | false     |

### What Happens During Theft Detection?

If Token A is reused (theft detected), we run:
```sql
UPDATE refresh_tokens SET is_revoked = true WHERE user_id = 'user123'
```

This kills **all three tokens** (A, B, C). The user gets logged out on **all devices** and must log in again everywhere.

**Why this aggressive approach?** We don't know which device was compromised, so we assume the worst and force a full re-authentication.

---

## Trade-offs: Security vs User Experience

### The Problem

We can't distinguish between:
- A hacker reusing a stolen token
- A legitimate user accidentally sending the same request twice (network glitch)

### The Decision

**Industry Standard:** Most apps (Google, GitHub, Auth0) choose **security over convenience**. They assume reuse = theft.

**Why?**
- If we **ignore** reuse, a real hacker could keep using stolen tokens.
- If we **block** reuse, innocent users occasionally get logged out (but their data stays safe).

### Better Solutions (Advanced)

1. **Grace Period**: Allow reuse within 5 seconds (assumes network retry).
2. **Device Fingerprinting**: If the same device sends the token twice, allow it.
3. **User Notification**: Email the user: "We detected suspicious activity. Was this you?"

For now, the simple approach is: **Reuse = Theft = Logout All Devices**.
